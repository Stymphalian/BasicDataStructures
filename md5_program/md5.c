#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

#include "md5.h"


#define ROTATE_LEFT(x,n) ( ((x) << (n))  | ((x) >>(32-n)) )
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)) )

/* make these into macros? */
static void r1(UINT32* A, UINT32* B, UINT32* C, UINT32* D, UINT32 X, int S, UINT32 T);
static void r2(UINT32* A, UINT32* B, UINT32* C, UINT32* D, UINT32 X, int S, UINT32 T);
static void r3(UINT32* A, UINT32* B, UINT32* C, UINT32* D, UINT32 X, int S, UINT32 T);
static void r4(UINT32* A, UINT32* B, UINT32* C, UINT32* D, UINT32 X, int S, UINT32 T);

static void perform_round_1(UINT32 state[4], UINT32* X, UINT32* T );
static void perform_round_2(UINT32 state[4], UINT32* X, UINT32* T );
static void perform_round_3(UINT32 state[4], UINT32* X, UINT32* T );
static void perform_round_4(UINT32 state[4], UINT32* X, UINT32* T );
static unsigned char* gen_padding(unsigned char* padding);


/* generated by
 *
 * for( i = 0; i < 64; ++i) {
 *		T[i] = abs(sin(i+1))*(2^32);
 * }
 */
static UINT32 T[64] = {
	0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee,
	0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,
	0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be,
	0x6b901122,0xfd987193,0xa679438e,0x49b40821,
	0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa,
	0xd62f105d,0x2441453,0xd8a1e681,0xe7d3fbc8,
	0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,
	0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a,
	0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c,
	0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70,
	0x289b7ec6,0xeaa127fa,0xd4ef3085,0x4881d05,
	0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,
	0xf4292244,0x432aff97,0xab9423a7,0xfc93a039,
	0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1,
	0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1,
	0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391
};


/* initializes the MD Registers/context */
void init_context(MD_CTX* context){
	context->state[0] = 0x67452301;
	context->state[1] = 0xefcdab89;
	context->state[2] = 0x98badcfe;
	context->state[3] = 0x10325476; 
	context->count[0] = 0;
	context->count[1] = 0;

	return;
}


/* buffer must be 512 bits long (i.e. 64 bytes, i.e. 32bits * 16 ) */
void update_context(MD_CTX* ctx,unsigned char buffer[64]){
	UINT32 AA = ctx->state[0]; /* preserve the current state */
	UINT32 BB = ctx->state[1];
	UINT32 CC = ctx->state[2];
	UINT32 DD = ctx->state[3];
	UINT32 X[16];

	memcpy(X, buffer, 64); /* copy into X */

	perform_round_1(ctx->state,X,T); /* perform the rounds */
	perform_round_2(ctx->state,X,T); /* T is statically defined above */
	perform_round_3(ctx->state,X,T);
	perform_round_4(ctx->state,X,T);


	ctx->state[0] += AA; /* add original values back into state */
	ctx->state[1] += BB;
	ctx->state[2] += CC;
	ctx->state[3] += DD;

	/* check for overflow of the current count of bits */
	if( (ctx->count[0] += 64*8) < 64*8){

		/* we note the behaviour. If the count[1] overflows this will
		 * cause count[1] to be set to 0,and any overflow from the
		 * count[0] will be recorded */
		ctx->count[1] += 1;
	}
	return;
}


/* This is the function which is used to perform the final updates
 * on the context. It is the function  which will perform the update on 
 * the context with the necessary padding of 1/0's and the 64-bit length
 * value 
 */
void update_final(MD_CTX* context,unsigned char buffer[64], UINT32 len){
	unsigned char padding[64]; /* 512 bits */
	unsigned char count_len[8]; /* 64 bits */


	/* update the count of bits read.
	 * Note we do this update of the count such that when
	 * we generate the correct 64-bit length value.
	 * We also note that the 64-bit length value is the value
	 * before adding the padding.
	 */
	if( (context->count[0] += len*8) < len*8){
		context->count[1] += 1;
	}

	gen_padding(padding);
	memcpy(count_len, context->count,8);

	/* This handles two cases:
	 *  len*8 == 448 AND
	 *  len*8 > 448 */
	if( len * 8 >= 448 ){
		/* update the context with the padding up to the 512 boundary */
		memcpy(buffer+len, padding, 64 - len); 
		update_context(context,buffer);	


		/* perform another update on the context. 
		 * This time with a buffer which is padded with 1/0s
		 * and the 64-bit length value  */
		memcpy(buffer,padding+1,56); /* +1 so that we don't copy over the 0x80*/
		memcpy(buffer+56,count_len, 8);

	/* len*8 < 448, then we need only pad up the 448 boundary,
	 * and then add the 64-bit length appending */
	}else if (len*8 < 448 ){
		memcpy(buffer+len, padding,56-len); /* copy padding up to the 448 bits mark */
		memcpy(buffer+56,count_len, 8); /* add the 64-bit length/count value */
	}

	/* do the final update of the context */
	update_context(context,buffer);
}



static void r1(UINT32* A, UINT32* B, UINT32* C, UINT32* D, UINT32 X,int S, UINT32 T2){
	*A = *A + F(*B,*C,*D) + X + T2;
	*A = ROTATE_LEFT(*A,S);
	*A = *A + *B;
}
static void r2(UINT32* A, UINT32* B, UINT32* C, UINT32* D, UINT32 X,int S, UINT32 T2){
	*A = *A + G(*B,*C,*D) + X  + T2;
	*A = ROTATE_LEFT(*A, S);
	*A = *A + *B;
}
static void r3(UINT32* A, UINT32* B, UINT32* C, UINT32* D, UINT32 X,int S, UINT32 T2){
	*A = *A + H(*B,*C,*D) + X  + T2;
	*A = ROTATE_LEFT(*A, S);
	*A = *A + *B;
	
}
static void r4(UINT32* A, UINT32* B, UINT32* C, UINT32* D, UINT32 X, int S, UINT32 T2){
	*A = (*A) + I(*B,*C,*D) + X + T2;
	*A = ROTATE_LEFT(*A, S);
	*A = *A + *B;
}

static void perform_round_1(UINT32 state[4], UINT32* X, UINT32* T2){
	static int S[4] = {7,12,17,22};
	int i;
	int j = 0;
	int s = 0;
	int m = 4;
	for( i = 0; i < 16; ++i){
		r1(state+(m%4),state+((m+1)%4),state+((m+2)%4),state+((m+3)%4),X[j],S[s], T2[i]);
		s = (s+1)%4;
		j = (j+1)%16;
		m = (m-1 == 0) ? 4: m-1;
	}
}
static void perform_round_2(UINT32 state[4], UINT32* X, UINT32* T2){
	static int S[4] = {5,9,14,20};
	int i = 0;
	int j = 1;
	int s = 0;
	int m = 4;
	for( i = 16; i < 32; ++i){
		r2(state+(m%4),state+((m+1)%4),state+((m+2)%4),state+((m+3)%4),X[j],S[s], T2[i]);
		s = (s+1)%4;
		j = (j+5)%16;
		m = (m-1 == 0) ? 4: m-1;
	}
}
static void perform_round_3(UINT32 state[4],UINT32* X, UINT32* T2){
	static int S[4] = {4,11,16,23};
	int i ;
	int j = 5;
	int s = 0;
	int m = 4;
	for( i = 32; i < 48; ++i){
		r3(state+(m%4),state+((m+1)%4),state+((m+2)%4),state+((m+3)%4),X[j],S[s], T2[i]);
		s = (s+1)%4;
		j = (j+3)%16;
		m = (m-1 == 0) ? 4: m-1;
	}
}
static void perform_round_4(UINT32 state[4], UINT32* X, UINT32* T2){
	static int S[4] = {6,10,15,21};
	int i;
	int j = 0;
	int s = 0;
	int m = 4;
	for( i = 48; i < 64; ++i){
		r4(state+(m%4),state+((m+1)%4),state+((m+2)%4),state+((m+3)%4),X[j],S[s], T2[i]);
		s = (s+1)%4;
		j = (j+7)%16;
		m = (m-1 == 0) ? 4: m-1;
	}
}

/* not too sure if this works */
/* We want bits to be added, but the smallest unit that we can work with is a byte */
static unsigned char* gen_padding(unsigned char* padding){
	padding[0] = 0x80; /* 0x80 */
	int i = 0;
	for(i =1; i < 64; ++i){
		padding[i] = 0x00;
	}
	return padding;
}



